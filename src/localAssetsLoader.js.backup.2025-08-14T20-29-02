// Sistema de carregamento híbrido: assets locais + API fallback com circuit breaker
import { getGaleriaCache, setGaleriaCache } from './cacheGalerias';

// Mapeamento das imagens locais por pasta
const LOCAL_IMAGES_MAP = {
  'casamentos': [
    'a5xt20fdzr3ho2uu7cxu.avif',
    'ap1iuoatx0cberzj1jpz.avif',
    'dgy5dwwf0fjydt5ip1l6.avif',
    'ewziw1hcn9weaqfi218f.avif',
    'gp7lluo61tuvon5z3sh9.avif',
    'hufowfutpsfqxigtnytm.avif',
    'lthyxecyi8o0ob7zdzqd.avif',
    'r1li6iiejwzq7tlw6vfb.avif'
  ],
  'femininos': [
    'e01k6gneioasriizga4h.avif',
    'gwxca41ogws1eeyutovf.avif',
    'htometcjoc1gbvn8zjgk.avif',
    'k1trj7r9heam46yqrmhb.avif',
    'mthhdtijmao2goomjaqf.avif',
    'oul0h8eryh6zjsohezth.avif',
    'sq0ka0xetbvitnc5af3j.avif',
    'umxtmulo4crn14w6wubs.avif',
    'vwjsug1444v951vqxwls.avif',
    'wrzosyiycspvsguldqrd.avif',
    'yfzfookalypyatfxegaz.avif',
    'yk7ecoya8km2qcsstzgl.avif',
    'ymwnbfwvfnlpthilvsyv.avif',
    'yt4tf3whckrxefm48tfq.avif'
  ],
  'infantil': [
    'a9qjgpbbnzeqmfsxu9xw.avif',
    'gvwi6jl6uej5s7jv8fxu.avif',
    'h3lfjzkohlzcavxahz6r.avif',
    'jifpinhpnllwjmayavuy.avif',
    'ogrhm6mbjj4orapxkbvm.avif',
    'pfeeq3lcnelpdw7ghmqb.avif',
    'vtwzylieacjnjkpxrg6w.avif',
    'woj8kwyexyf6vumevxgu.avif',
    'yfyy2kt729bbwyfztqka.avif'
  ],
  'noivas': [
    'dvvackjvoomhqatvegzv.avif',
    'f1ymuhdhw5jvpy3uqxov.avif',
    'hityrsyamsgtyd49vvuq.avif',
    'scnghfhqviflkfo3iyq4.avif',
    't1n3kqea9tcxozocpjk9.avif',
    'tdjhviclwuxqc54e2fio.avif',
    'xgmxxnj0dqgvz4bhxj3w.avif'
  ],
  'pre-weding': [
    'edc4ueah6cwvxguifmya.avif',
    'g5iyxwan5xan2yd9kvsd.avif',
    'ljux2wq2yv7u5tfbx566.avif',
    'm3ptql45moedtyiu95b2.avif',
    'mx7qfltqchnji7obzib3.avif',
    'w7e8ej2x8oiy16pwa6j3.avif',
    'xfzdkucp2xgwx0bfszto.avif',
    'zlqk8kyrkg16jgfkgg25.avif',
    'zzlrug9ygaikimepy3yz.avif'
  ]
};

// Circuit Breaker para controlar fallback para API
class CircuitBreaker {
  constructor(failureThreshold = 3, timeout = 60000) {
    this.failureThreshold = failureThreshold;
    this.timeout = timeout;
    this.failureCount = 0;
    this.lastFailureTime = null;
    this.state = 'CLOSED'; // CLOSED, OPEN, HALF_OPEN
  }

  async call(fn) {
    if (this.state === 'OPEN') {
      if (Date.now() - this.lastFailureTime > this.timeout) {
        this.state = 'HALF_OPEN';
      } else {
        throw new Error('Circuit breaker is OPEN');
      }
    }

    try {
      const result = await fn();
      this.onSuccess();
      return result;
    } catch (error) {
      this.onFailure();
      throw error;
    }
  }

  onSuccess() {
    this.failureCount = 0;
    this.state = 'CLOSED';
  }

  onFailure() {
    this.failureCount++;
    this.lastFailureTime = Date.now();
    
    if (this.failureCount >= this.failureThreshold) {
      this.state = 'OPEN';
    }
  }
}

// Instância global do circuit breaker
const apiCircuitBreaker = new CircuitBreaker(3, 30000); // 3 falhas, 30s timeout

// Função para carregar imagens locais
export function loadLocalImages(pasta) {
  console.log(`🏠 Carregando imagens locais para pasta: ${pasta}`);
  
  const localImages = LOCAL_IMAGES_MAP[pasta];
  if (!localImages || !Array.isArray(localImages)) {
    console.warn(`❌ Pasta '${pasta}' não encontrada no mapeamento local`);
    return [];
  }

  // Converte para o formato esperado pelo sistema atual
  return localImages.map((filename, index) => ({
    url: `/images/galeria/${pasta}/${filename}`,
    thumb: `/images/galeria/${pasta}/${filename}`, // Mesmo arquivo (já otimizado em AVIF)
    width: 800, // Valores padrão - podem ser ajustados
    height: 1200,
    format: 'avif',
    public_id: `local_${pasta}_${index}`,
    isLocal: true // Flag para identificar imagens locais
  }));
}

// Função para carregar via API (com circuit breaker)
async function loadFromAPI(pasta) {
  console.log(`🌐 Tentando carregar via API para pasta: ${pasta}`);
  
  const apiUrl = import.meta.env.VITE_API_URL;
  
  return await apiCircuitBreaker.call(async () => {
    const response = await fetch(`${apiUrl}/galeria/${encodeURIComponent(pasta)}`, {
      timeout: 10000 // 10s timeout
    });
    
    if (!response.ok) {
      throw new Error(`API retornou status ${response.status}`);
    }
    
    const data = await response.json();
    return data.images || [];
  });
}

// Função principal híbrida com fallback
export async function loadGalleryImages(pasta) {
  console.log(`🔄 Iniciando carregamento híbrido para pasta: ${pasta}`);
  
  // Verifica cache primeiro
  const cachedImages = getGaleriaCache(pasta);
  if (cachedImages && cachedImages.length > 0) {
    console.log(`💾 Imagens encontradas no cache para pasta: ${pasta}`);
    return cachedImages;
  }

  try {
    // Estratégia 1: Tenta carregar imagens locais primeiro
    const localImages = loadLocalImages(pasta);
    
    if (localImages && localImages.length > 0) {
      console.log(`✅ ${localImages.length} imagens locais carregadas para pasta: ${pasta}`);
      
      // Valida se as imagens locais existem realmente
      const validatedImages = await validateLocalImages(localImages);
      
      if (validatedImages.length > 0) {
        setGaleriaCache(pasta, validatedImages);
        return validatedImages;
      } else {
        console.warn(`⚠️ Nenhuma imagem local válida encontrada para pasta: ${pasta}`);
      }
    }

    // Estratégia 2: Fallback para API
    console.log(`🔄 Tentando fallback para API para pasta: ${pasta}`);
    const apiImages = await loadFromAPI(pasta);
    
    if (apiImages && apiImages.length > 0) {
      console.log(`✅ ${apiImages.length} imagens carregadas via API para pasta: ${pasta}`);
      setGaleriaCache(pasta, apiImages);
      return apiImages;
    }

    console.warn(`⚠️ Nenhuma imagem encontrada via API para pasta: ${pasta}`);
    return [];

  } catch (error) {
    console.error(`❌ Erro no carregamento híbrido para pasta ${pasta}:`, error);
    
    // Último recurso: retorna imagens locais mesmo que algumas possam estar quebradas
    const localImages = loadLocalImages(pasta);
    if (localImages && localImages.length > 0) {
      console.log(`🆘 Usando imagens locais como último recurso para pasta: ${pasta}`);
      return localImages;
    }
    
    return [];
  }
}

// Valida se as imagens locais realmente existem
async function validateLocalImages(images) {
  console.log(`🔍 Validando ${images.length} imagens locais...`);
  
  const validImages = [];
  
  // Valida em lotes para melhor performance
  const batchSize = 5;
  for (let i = 0; i < images.length; i += batchSize) {
    const batch = images.slice(i, i + batchSize);
    const promises = batch.map(async (image) => {
      try {
        const response = await fetch(image.url, { method: 'HEAD' });
        return response.ok ? image : null;
      } catch {
        return null;
      }
    });
    
    const results = await Promise.all(promises);
    validImages.push(...results.filter(img => img !== null));
  }
  
  console.log(`✅ ${validImages.length}/${images.length} imagens locais validadas`);
  return validImages;
}

// Função para obter estatísticas do circuit breaker
export function getCircuitBreakerStats() {
  return {
    state: apiCircuitBreaker.state,
    failureCount: apiCircuitBreaker.failureCount,
    lastFailureTime: apiCircuitBreaker.lastFailureTime
  };
}

// Função para resetar o circuit breaker (útil para debug/admin)
export function resetCircuitBreaker() {
  apiCircuitBreaker.failureCount = 0;
  apiCircuitBreaker.state = 'CLOSED';
  apiCircuitBreaker.lastFailureTime = null;
  console.log('🔄 Circuit breaker resetado');
}
